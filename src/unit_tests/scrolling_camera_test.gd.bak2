extends Node2D
# ScrollingCamera Test: A comprehensive test suite for the ScrollingCamera system

# ===== TEST CONFIGURATION =====
var run_all_tests = true  # Set to false to run only specific tests
var log_debug_info = true  # Set to true for more verbose output

# Test-specific flags
var test_state_listener_system = true
var test_signal_data = true
var test_state_query_methods = true
var test_ui_element_synchronization = true
var test_transition_event_system = true
var test_debug_visualization = true

# ===== TEST VARIABLES =====
var camera: Camera2D
var test_results = {}
var current_test = ""
var tests_passed = 0
var tests_failed = 0
var failed_tests = []

# Mock objects for testing
class MockListener:
	var received_signals = {}
	var name = "MockListener"
	
	func _init():
		clear_signals()
	
	func clear_signals():
		received_signals = {
			"state_changed": [],
			"move_started": [],
			"move_completed": [],
			"view_bounds_changed": [],
			"transition_progress": [],
			"transition_point": []
		}
	
	func _on_camera_state_changed(new_state, old_state, reason):
		received_signals.state_changed.append({
			"new_state": new_state,
			"old_state": old_state,
			"reason": reason
		})
	
	func _on_camera_move_started(target_position, old_position, move_duration, transition_type):
		received_signals.move_started.append({
			"target_position": target_position,
			"old_position": old_position,
			"move_duration": move_duration,
			"transition_type": transition_type
		})
	
	func _on_camera_move_completed(final_position, initial_position, actual_duration):
		received_signals.move_completed.append({
			"final_position": final_position,
			"initial_position": initial_position,
			"actual_duration": actual_duration
		})
	
	func _on_camera_view_bounds_changed(new_bounds, old_bounds, is_district_change):
		received_signals.view_bounds_changed.append({
			"new_bounds": new_bounds,
			"old_bounds": old_bounds,
			"is_district_change": is_district_change
		})
	
	func _on_camera_transition_progress(progress, position, target_position):
		received_signals.transition_progress.append({
			"progress": progress,
			"position": position,
			"target_position": target_position
		})
	
	func _on_transition_point_reached(point, position, progress):
		received_signals.transition_point.append({
			"point": point,
			"position": position,
			"progress": progress
		})

class MockUIElement:
	var sync_calls = []
	var state_change_calls = []
	var move_completed_calls = []
	var name = "MockUIElement"
	
	func clear_calls():
		sync_calls = []
		state_change_calls = []
		move_completed_calls = []
	
	func sync_with_camera_movement(progress, from_pos, to_pos):
		sync_calls.append({
			"progress": progress,
			"from_pos": from_pos,
			"to_pos": to_pos
		})
	
	func on_camera_state_changed(new_state, old_state):
		state_change_calls.append({
			"new_state": new_state,
			"old_state": old_state
		})
	
	func on_camera_move_completed():
		move_completed_calls.append({
			"time": OS.get_ticks_msec()
		})

# Mock objects
var mock_listener
var mock_ui_element

# ===== LIFECYCLE METHODS =====

func _ready():
	# Set up the test environment
	debug_log("Setting up camera system test...")
	
	# Initialize mock objects
	mock_listener = MockListener.new()
	mock_ui_element = MockUIElement.new()
	add_child(mock_listener)
	add_child(mock_ui_element)
	
	# Find or create the camera
	camera = find_camera()
	if not camera:
		debug_log("ERROR: Could not find or create a ScrollingCamera instance", true)
		return
	
	# Configure camera for testing
	configure_camera()
	
	# Run the tests
	yield(get_tree().create_timer(0.5), "timeout")  # Short delay to ensure setup is complete
	yield(run_tests(), "completed")
	
	# Report results
	report_results()

func _process(delta):
	# Update the status display if needed
	pass

# ===== TEST SETUP METHODS =====

func find_camera():
	# Try to find the ScrollingCamera in the scene
	var cameras = get_tree().get_nodes_in_group("camera")
	for cam in cameras:
		if cam is Camera2D:
			debug_log("Found existing camera: " + cam.name)
			return cam
	
	# If no camera found, look for our specific class
	for node in get_tree().get_nodes_in_group("camera"):
		if "CameraState" in node:
			debug_log("Found ScrollingCamera: " + node.name)
			return node
	
	# Create a new camera if no existing camera found
	debug_log("Creating new ScrollingCamera instance")
	var scene = load("res://src/core/camera/scrolling_camera.gd")
	if scene:
		var new_camera = scene.new()
		add_child(new_camera)
		return new_camera
	
	return null

func configure_camera():
	debug_log("Configuring camera for testing...")
	
	# Enable debug visualization for testing
	camera.debug_draw = true
	camera.signal_debug_mode = true
	
	# Ensure the camera has specific testing properties
	camera.bounds_enabled = true
	camera.camera_bounds = Rect2(0, 0, 1000, 1000)
	
	# Set initial position
	camera.global_position = Vector2(500, 500)
	
	debug_log("Camera configured with position: " + str(camera.global_position))

# ===== TEST RUNNER =====

func run_tests():
	debug_log("Starting camera system tests...")
	
	# Reset test counters
	tests_passed = 0
	tests_failed = 0
	failed_tests = []
	test_results = {}
	
	# Run all test suites in sequence
	if run_all_tests or test_state_listener_system:
		yield(test_state_listener_system_suite(), "completed")
	
	if run_all_tests or test_signal_data:
		yield(test_signal_data_suite(), "completed")
	
	if run_all_tests or test_state_query_methods:
		yield(test_state_query_methods_suite(), "completed")
	
	if run_all_tests or test_ui_element_synchronization:
		yield(test_ui_element_synchronization_suite(), "completed")
	
	if run_all_tests or test_transition_event_system:
		yield(test_transition_event_system_suite(), "completed")
	
	if run_all_tests or test_debug_visualization:
		yield(test_debug_visualization_suite(), "completed")
	
	debug_log("All tests completed.")

# ===== TEST SUITES =====

func test_state_listener_system_suite():
	start_test_suite("State Listener System")
	
	# Test 1: Connect listener
	yield(test_connect_state_listener(), "completed")
	
	# Test 2: Verify listener receives signals
	yield(test_listener_receives_signals(), "completed")
	
	# Test 3: Test auto-disconnection when freed
	yield(test_listener_auto_disconnect(), "completed")
	
	# Test 4: Manual disconnect
	yield(test_manual_disconnect(), "completed")
	
	end_test_suite()
	yield(get_tree(), "idle_frame")

func test_signal_data_suite():
	start_test_suite("Signal Data Enhancement")
	
	# Test 1: Verify camera_move_started signal contains all expected data
	yield(test_move_started_signal_data(), "completed")
	
	# Test 2: Verify camera_move_completed signal contains all expected data
	yield(test_move_completed_signal_data(), "completed")
	
	# Test 3: Verify camera_state_changed signal contains all expected data
	yield(test_state_changed_signal_data(), "completed")
	
	# Test 4: Verify view_bounds_changed signal contains all expected data
	yield(test_view_bounds_changed_signal_data(), "completed")
	
	end_test_suite()
	yield(get_tree(), "idle_frame")

func test_state_query_methods_suite():
	start_test_suite("State Query Methods")
	
	# Test 1: Basic state getters
	yield(test_basic_state_getters(), "completed")
	
	# Test 2: Movement progress tracking
	yield(test_movement_progress_tracking(), "completed")
	
	# Test 3: Boundary detection
	yield(test_boundary_detection(), "completed")
	
	end_test_suite()
	yield(get_tree(), "idle_frame")

func test_ui_element_synchronization_suite():
	start_test_suite("UI Element Synchronization")
	
	# Test 1: Register UI element
	yield(test_register_ui_element(), "completed")
	
	# Test 2: UI element receives updates during movement
	yield(test_ui_element_receives_updates(), "completed")
	
	# Test 3: Unregister UI element
	yield(test_unregister_ui_element(), "completed")
	
	end_test_suite()
	yield(get_tree(), "idle_frame")

func test_transition_event_system_suite():
	start_test_suite("Transition Event System")
	
	# Test 1: Register transition callback
	yield(test_register_transition_callback(), "completed")
	
	# Test 2: Transition events triggered
	yield(test_transition_events_triggered(), "completed")
	
	# Test 3: Custom transition points
	yield(test_custom_transition_points(), "completed")
	
	end_test_suite()
	yield(get_tree(), "idle_frame")

func test_debug_visualization_suite():
	start_test_suite("Debug Visualization")
	
	# Test 1: State change visuals
	yield(test_state_change_visuals(), "completed")
	
	# Test 2: Transition point visuals
	yield(test_transition_point_visuals(), "completed")
	
	end_test_suite()
	yield(get_tree(), "idle_frame")

# ===== INDIVIDUAL TESTS =====

# STATE LISTENER SYSTEM TESTS

func test_connect_state_listener():
	start_test("Connect State Listener")
	
	# Ensure mock is clean
	mock_listener.clear_signals()
	
	# Connect the mock listener
	camera.connect_state_listener(mock_listener, "_on_camera_state_changed")
	
	# Check if connection is successful by triggering a state change
	camera.set_camera_state(camera.CameraState.IDLE)
	yield(get_tree().create_timer(0.1), "timeout")
	
	# Verify listener received signal
	var passed = mock_listener.received_signals.state_changed.size() > 0
	end_test(passed, "Listener should receive state change signal")
	yield(get_tree(), "idle_frame")

func test_listener_receives_signals():
	start_test("Listener Receives All Signal Types")
	
	# Ensure mock is clean
	mock_listener.clear_signals()
	
	# Connect all signal types
	camera.connect_state_listener(mock_listener, "_on_camera_state_changed")
	camera.connect_move_started_listener(mock_listener, "_on_camera_move_started")
	camera.connect_move_completed_listener(mock_listener, "_on_camera_move_completed")
	camera.connect_view_bounds_listener(mock_listener, "_on_camera_view_bounds_changed")
	camera.connect("camera_transition_progress", mock_listener, "_on_camera_transition_progress")
	camera.connect("camera_transition_point_reached", mock_listener, "_on_transition_point_reached")
	
	# Trigger signals
	camera.set_camera_state(camera.CameraState.MOVING)
	var original_pos = camera.global_position
	camera.target_position = original_pos + Vector2(100, 0)
	
	# Let some frames pass for movement to progress
	for i in range(5):
		yield(get_tree(), "idle_frame")
	
	# Force movement completion
	camera.set_camera_state(camera.CameraState.IDLE)
	
	# Update bounds to trigger view_bounds_changed
	var old_bounds = camera.camera_bounds
	camera.camera_bounds = Rect2(0, 0, 1200, 1200)
	
	# Emit the bounds changed signal manually to test
	camera.emit_signal("view_bounds_changed", camera.camera_bounds, old_bounds, true)
	
	yield(get_tree().create_timer(0.2), "timeout")
	
	# Count received signals
	var received_types = 0
	if mock_listener.received_signals.state_changed.size() > 0: received_types += 1
	if mock_listener.received_signals.move_started.size() > 0: received_types += 1
	if mock_listener.received_signals.move_completed.size() > 0: received_types += 1
	if mock_listener.received_signals.view_bounds_changed.size() > 0: received_types += 1
	
	# Reset camera position
	camera.global_position = original_pos
	
	# Test passes if at least 4 signal types were received
	end_test(received_types >= 4, "Listener should receive at least 4 different signal types")
	yield(get_tree(), "idle_frame")

func test_listener_auto_disconnect():
	start_test("Listener Auto-Disconnect")
	
	# Create a temporary listener
	var temp_listener = MockListener.new()
	temp_listener.name = "TempListener"
	add_child(temp_listener)
	
	# Connect the temp listener
	camera.connect_state_listener(temp_listener, "_on_camera_state_changed")
	
	# Trigger a state change
	camera.set_camera_state(camera.CameraState.IDLE)
	yield(get_tree().create_timer(0.1), "timeout")
	
	# Verify listener received signal
	var received_before = temp_listener.received_signals.state_changed.size() > 0
	
	# Free the listener
	temp_listener.queue_free()
	yield(get_tree().create_timer(0.2), "timeout")
	
	# Trigger another state change
	camera.set_camera_state(camera.CameraState.FOLLOWING_PLAYER)
	yield(get_tree().create_timer(0.1), "timeout")
	
	# Reset camera state
	camera.set_camera_state(camera.CameraState.IDLE)
	
	# Test passes if listener received signal before being freed
	# We can't verify it didn't receive after being freed since the object is gone
	end_test(received_before, "Listener should receive signals before being freed")
	yield(get_tree(), "idle_frame")

func test_manual_disconnect():
	start_test("Manual Disconnect")
	
	# Ensure mock is clean
	mock_listener.clear_signals()
	
	# Connect the mock listener
	camera.connect_state_listener(mock_listener, "_on_camera_state_changed")
	
	# Trigger a state change
	camera.set_camera_state(camera.CameraState.MOVING)
	yield(get_tree().create_timer(0.1), "timeout")
	
	# Verify listener received signal
	var received_before = mock_listener.received_signals.state_changed.size() > 0
	
	# Manually disconnect
	camera.disconnect_listener(mock_listener)
	
	# Clear signals
	mock_listener.clear_signals()
	
	# Trigger another state change
	camera.set_camera_state(camera.CameraState.IDLE)
	yield(get_tree().create_timer(0.1), "timeout")
	
	# Verify listener did not receive signal
	var received_after = mock_listener.received_signals.state_changed.size() > 0
	
	# Test passes if listener received before disconnect but not after
	end_test(received_before && !received_after, "Listener should receive signals before disconnect but not after")
	yield(get_tree(), "idle_frame")

# SIGNAL DATA TESTS

func test_move_started_signal_data():
	start_test("Move Started Signal Data")
	
	# Ensure mock is clean
	mock_listener.clear_signals()
	
	# Connect the move started signal
	camera.connect_move_started_listener(mock_listener, "_on_camera_move_started")
	
	# Save original position
	var original_pos = camera.global_position
	var target_pos = original_pos + Vector2(100, 0)
	
	# Trigger movement
	camera.target_position = target_pos
	camera.set_camera_state(camera.CameraState.MOVING)
	
	# Wait for signal to be processed
	yield(get_tree().create_timer(0.2), "timeout")
	
	# Reset camera
	camera.set_camera_state(camera.CameraState.IDLE)
	camera.global_position = original_pos
	
	# Verify signal data
	var passed = false
	if mock_listener.received_signals.move_started.size() > 0:
		var signal_data = mock_listener.received_signals.move_started[0]
		passed = signal_data.has("target_position") && \
				signal_data.has("old_position") && \
				signal_data.has("move_duration") && \
				signal_data.has("transition_type")
	
	end_test(passed, "Move started signal should contain all required data fields")
	yield(get_tree(), "idle_frame")

func test_move_completed_signal_data():
	start_test("Move Completed Signal Data")
	
	# Ensure mock is clean
	mock_listener.clear_signals()
	
	# Connect the move completed signal
	camera.connect_move_completed_listener(mock_listener, "_on_camera_move_completed")
	
	# Save original position
	var original_pos = camera.global_position
	var target_pos = original_pos + Vector2(100, 0)
	
	# Trigger movement and immediate completion
	camera.target_position = target_pos
	camera.move_to_position(target_pos, true)  # Immediate move
	
	# Wait for signal to be processed
	yield(get_tree().create_timer(0.2), "timeout")
	
	# Reset camera position
	camera.global_position = original_pos
	
	# Verify signal data
	var passed = false
	if mock_listener.received_signals.move_completed.size() > 0:
		var signal_data = mock_listener.received_signals.move_completed[0]
		passed = signal_data.has("final_position") && \
				signal_data.has("initial_position") && \
				signal_data.has("actual_duration")
	
	end_test(passed, "Move completed signal should contain all required data fields")
	yield(get_tree(), "idle_frame")

func test_state_changed_signal_data():
	start_test("State Changed Signal Data")
	
	# Ensure mock is clean
	mock_listener.clear_signals()
	
	# Connect the state changed signal
	camera.connect_state_listener(mock_listener, "_on_camera_state_changed")
	
	# Trigger state change with reason
	camera.set_camera_state(camera.CameraState.FOLLOWING_PLAYER, "test_reason")
	
	# Wait for signal to be processed
	yield(get_tree().create_timer(0.1), "timeout")
	
	# Reset camera state
	camera.set_camera_state(camera.CameraState.IDLE)
	
	# Verify signal data
	var passed = false
	if mock_listener.received_signals.state_changed.size() > 0:
		var signal_data = mock_listener.received_signals.state_changed[0]
		passed = signal_data.has("new_state") && \
				signal_data.has("old_state") && \
				signal_data.has("reason") && \
				signal_data.reason == "test_reason"
	
	end_test(passed, "State changed signal should contain all required data fields including reason")
	yield(get_tree(), "idle_frame")

func test_view_bounds_changed_signal_data():
	start_test("View Bounds Changed Signal Data")
	
	# Ensure mock is clean
	mock_listener.clear_signals()
	
	# Connect the view bounds changed signal
	camera.connect_view_bounds_listener(mock_listener, "_on_camera_view_bounds_changed")
	
	# Get current bounds
	var old_bounds = camera.camera_bounds
	var new_bounds = Rect2(0, 0, 1500, 1500)
	
	# Trigger bounds change by emitting the signal manually
	camera.emit_signal("view_bounds_changed", new_bounds, old_bounds, true)
	
	# Wait for signal to be processed
	yield(get_tree().create_timer(0.1), "timeout")
	
	# Verify signal data
	var passed = false
	if mock_listener.received_signals.view_bounds_changed.size() > 0:
		var signal_data = mock_listener.received_signals.view_bounds_changed[0]
		passed = signal_data.has("new_bounds") && \
				signal_data.has("old_bounds") && \
				signal_data.has("is_district_change")
	
	end_test(passed, "View bounds changed signal should contain all required data fields")
	yield(get_tree(), "idle_frame")

# STATE QUERY METHODS TESTS

func test_basic_state_getters():
	start_test("Basic State Getters")
	
	# Set to a known state
	camera.set_camera_state(camera.CameraState.IDLE)
	
	# Check state getters
	var idle_state = camera.is_idle()
	var moving_state = camera.is_moving()
	var following_state = camera.is_following_player()
	var get_state = camera.get_camera_state() == camera.CameraState.IDLE
	
	# Test passes if all state getters return expected values
	var passed = idle_state && !moving_state && !following_state && get_state
	end_test(passed, "State getters should return correct values")
	yield(get_tree(), "idle_frame")

func test_movement_progress_tracking():
	start_test("Movement Progress Tracking")
	
	# Save original position
	var original_pos = camera.global_position
	var target_pos = original_pos + Vector2(200, 0)
	
	# Start movement
	camera.target_position = target_pos
	camera.set_camera_state(camera.CameraState.MOVING)
	
	# Check progress initially
	var initial_progress = camera.get_movement_progress()
	var initial_time = camera.get_movement_elapsed_time()
	
	# Let movement progress
	yield(get_tree().create_timer(0.2), "timeout")
	
	# Check progress after some time
	var mid_progress = camera.get_movement_progress()
	var mid_time = camera.get_movement_elapsed_time()
	
	# Reset camera
	camera.set_camera_state(camera.CameraState.IDLE)
	camera.global_position = original_pos
	
	# Test passes if progress and time increased during movement
	var passed = mid_progress > initial_progress && mid_time > initial_time
	end_test(passed, "Movement progress and elapsed time should increase during movement")
	yield(get_tree(), "idle_frame")

func test_boundary_detection():
	start_test("Boundary Detection")
	
	# Save original position
	var original_pos = camera.global_position
	
	# Set camera bounds
	camera.camera_bounds = Rect2(0, 0, 1000, 1000)
	
	# Move camera to center (not at boundary)
	camera.global_position = Vector2(500, 500)
	
	# Check boundary detection at center
	var at_center_boundary = camera.is_at_boundary()
	
	# Move camera to left edge
	camera.global_position = Vector2(10, 500)
	
	# Check boundary detection at edge
	var at_left_boundary = camera.is_at_boundary("left")
	
	# Get nearest boundary direction
	var boundary_dir = camera.get_nearest_boundary_direction()
	
	# Reset camera position
	camera.global_position = original_pos
	
	# Test passes if boundary detection matches expected results
	var passed = !at_center_boundary && at_left_boundary && boundary_dir.x < 0
	end_test(passed, "Boundary detection should correctly identify camera position relative to bounds")
	yield(get_tree(), "idle_frame")

# UI ELEMENT SYNCHRONIZATION TESTS

func test_register_ui_element():
	start_test("Register UI Element")
	
	# Clear previous calls
	mock_ui_element.clear_calls()
	
	# Register the UI element
	camera.register_ui_element(mock_ui_element)
	
	# Trigger a state change to see if the UI element receives it
	camera.set_camera_state(camera.CameraState.MOVING)
	
	# Wait for signal to be processed
	yield(get_tree().create_timer(0.1), "timeout")
	
	# Reset camera state
	camera.set_camera_state(camera.CameraState.IDLE)
	
	# Test passes if UI element received the state change
	var passed = mock_ui_element.state_change_calls.size() > 0
	end_test(passed, "UI element should receive state changes after registration")
	yield(get_tree(), "idle_frame")

func test_ui_element_receives_updates():
	start_test("UI Element Receives Movement Updates")
	
	# Clear previous calls
	mock_ui_element.clear_calls()
	
	# Make sure UI element is registered
	camera.register_ui_element(mock_ui_element)
	
	# Save original position
	var original_pos = camera.global_position
	var target_pos = original_pos + Vector2(100, 0)
	
	# Start movement
	camera.target_position = target_pos
	camera.set_camera_state(camera.CameraState.MOVING)
	
	# Let movement progress for a bit
	yield(get_tree().create_timer(0.2), "timeout")
	
	# Complete movement
	camera.set_camera_state(camera.CameraState.IDLE)
	
	# Reset camera position
	camera.global_position = original_pos
	
	# Test passes if UI element received sync calls and move completed
	var passed = mock_ui_element.sync_calls.size() > 0 && mock_ui_element.move_completed_calls.size() > 0
	end_test(passed, "UI element should receive movement updates and completion notification")
	yield(get_tree(), "idle_frame")

func test_unregister_ui_element():
	start_test("Unregister UI Element")
	
	# Clear previous calls
	mock_ui_element.clear_calls()
	
	# Make sure UI element is registered
	camera.register_ui_element(mock_ui_element)
	
	# Trigger a state change to verify registration
	camera.set_camera_state(camera.CameraState.MOVING)
	yield(get_tree().create_timer(0.1), "timeout")
	
	# Check if UI element received event
	var received_before = mock_ui_element.state_change_calls.size() > 0
	
	# Unregister the UI element
	camera.unregister_ui_element(mock_ui_element)
	
	# Clear previous calls
	mock_ui_element.clear_calls()
	
	# Trigger another state change
	camera.set_camera_state(camera.CameraState.IDLE)
	yield(get_tree().create_timer(0.1), "timeout")
	
	# Check if UI element received event after unregistering
	var received_after = mock_ui_element.state_change_calls.size() > 0
	
	# Test passes if UI element received events before but not after unregistering
	var passed = received_before && !received_after
	end_test(passed, "UI element should not receive updates after being unregistered")
	yield(get_tree(), "idle_frame")

# TRANSITION EVENT SYSTEM TESTS

func test_register_transition_callback():
	start_test("Register Transition Callback")
	
	# Clear previous signals
	mock_listener.clear_signals()
	
	# Connect to transition point signal
	camera.connect("camera_transition_point_reached", mock_listener, "_on_transition_point_reached")
	
	# Verify default transition points
	var has_default_points = camera.transition_event_points.size() > 0
	
	# Test passes if camera has default transition points
	end_test(has_default_points, "Camera should have default transition points")
	yield(get_tree(), "idle_frame")

func test_transition_events_triggered():
	start_test("Transition Events Triggered")
	
	# Clear previous signals
	mock_listener.clear_signals()
	
	# Connect to transition point signal
	camera.connect("camera_transition_point_reached", mock_listener, "_on_transition_point_reached")
	
	# Save original position
	var original_pos = camera.global_position
	var target_pos = original_pos + Vector2(200, 0)
	
	# Start movement
	camera.target_position = target_pos
	camera.set_camera_state(camera.CameraState.MOVING)
	
	# Let movement complete
	yield(get_tree().create_timer(1.0), "timeout")
	
	# Reset camera position
	camera.set_camera_state(camera.CameraState.IDLE)
	camera.global_position = original_pos
	
	# Test passes if at least one transition point was triggered
	var transition_points_triggered = mock_listener.received_signals.transition_point.size() > 0
	end_test(transition_points_triggered, "At least one transition point should be triggered during movement")
	yield(get_tree(), "idle_frame")

func test_custom_transition_points():
	start_test("Custom Transition Points")
	
	# Clear previous signals
	mock_listener.clear_signals()
	
	# Connect to transition point signal
	camera.connect("camera_transition_point_reached", mock_listener, "_on_transition_point_reached")
	
	# Set custom transition points
	var custom_points = [0.33, 0.66]
	camera.set_transition_event_points(custom_points)
	
	# Verify custom points were set
	var points_set = camera.transition_event_points.size() == 2
	
	# Save original position
	var original_pos = camera.global_position
	var target_pos = original_pos + Vector2(200, 0)
	
	# Start movement
	camera.target_position = target_pos
	camera.set_camera_state(camera.CameraState.MOVING)
	
	# Let movement complete
	yield(get_tree().create_timer(1.0), "timeout")
	
	# Reset camera position
	camera.set_camera_state(camera.CameraState.IDLE)
	camera.global_position = original_pos
	
	# Reset transition points
	camera.set_transition_event_points([0.25, 0.5, 0.75])
	
	# Check if custom transition points were triggered
	var point_values = []
	for point_data in mock_listener.received_signals.transition_point:
		point_values.append(point_data.point)
	
	# Test passes if custom points were set and at least one was triggered
	var custom_points_triggered = points_set && mock_listener.received_signals.transition_point.size() > 0
	end_test(custom_points_triggered, "Custom transition points should be correctly set and triggered")
	yield(get_tree(), "idle_frame")

# DEBUG VISUALIZATION TESTS

func test_state_change_visuals():
	start_test("State Change Visuals")
	
	# Enable debug visualization
	camera.debug_draw = true
	camera.debug_show_state_changes = true
	
	# Initial state
	camera.set_camera_state(camera.CameraState.IDLE)
	
	# Trigger state changes
	camera.set_camera_state(camera.CameraState.MOVING)
	yield(get_tree().create_timer(0.1), "timeout")
	camera.set_camera_state(camera.CameraState.FOLLOWING_PLAYER)
	yield(get_tree().create_timer(0.1), "timeout")
	camera.set_camera_state(camera.CameraState.IDLE)
	
	# Verify state change history exists
	var history_exists = camera.debug_state_change_history.size() > 0
	
	# Test passes if state change history exists
	end_test(history_exists, "State change history should be recorded for visualization")
	yield(get_tree(), "idle_frame")

func test_transition_point_visuals():
	start_test("Transition Point Visuals")
	
	# Enable debug visualization
	camera.debug_draw = true
	camera.debug_show_transition_points = true
	
	# Save original position
	var original_pos = camera.global_position
	var target_pos = original_pos + Vector2(200, 0)
	
	# Start movement
	camera.target_position = target_pos
	camera.set_camera_state(camera.CameraState.MOVING)
	
	# Let movement complete
	yield(get_tree().create_timer(1.0), "timeout")
	
	# Reset camera position
	camera.set_camera_state(camera.CameraState.IDLE)
	camera.global_position = original_pos
	
	# We can't easily test the visual output, so this test just verifies
	# the code runs without errors
	end_test(true, "Transition point visualization should run without errors")
	yield(get_tree(), "idle_frame")

# ===== TEST UTILITIES =====

func start_test_suite(suite_name):
	debug_log("===== TEST SUITE: " + suite_name + " =====", true)
	test_results[suite_name] = {
		"passed": 0,
		"failed": 0,
		"tests": {}
	}

func end_test_suite():
	var suite_name = current_test.split(":")[0]
	var passed = test_results[suite_name].passed
	var failed = test_results[suite_name].failed
	var total = passed + failed
	debug_log("Suite completed: " + str(passed) + "/" + str(total) + " tests passed", true)

func start_test(test_name):
	var suite_name = test_name.split(" ")[0]
	current_test = suite_name + ": " + test_name
	debug_log("Running test: " + test_name)

func end_test(passed, message = ""):
	var parts = current_test.split(": ")
	var suite_name = parts[0]
	var test_name = parts[1]
	
	if passed:
		debug_log("✓ PASS: " + test_name + (": " + message if message else ""))
		test_results[suite_name].passed += 1
		tests_passed += 1
	else:
		debug_log("✗ FAIL: " + test_name + (": " + message if message else ""), true)
		test_results[suite_name].failed += 1
		tests_failed += 1
		failed_tests.append(current_test)
	
	test_results[suite_name].tests[test_name] = {
		"passed": passed,
		"message": message
	}

func report_results():
	debug_log("\n===== TEST RESULTS =====", true)
	debug_log("Total Tests: " + str(tests_passed + tests_failed), true)
	debug_log("Passed: " + str(tests_passed), true)
	debug_log("Failed: " + str(tests_failed), true)
	
	if tests_failed > 0:
		debug_log("\nFailed Tests:", true)
		for test in failed_tests:
			var parts = test.split(": ")
			var suite_name = parts[0]
			var test_name = parts[1]
			var message = test_results[suite_name].tests[test_name].message
			debug_log("- " + test + (": " + message if message else ""), true)
	
	if tests_failed == 0:
		debug_log("\nAll tests passed! 🎉", true)

func debug_debug_log(message, force_print = false):
	if log_debug_info || force_print:
		print(message)