extends Node2D
# View Mode Transition Test: Tests transitions between game view and world view modes

# ===== TEST CONFIGURATION =====
var run_all_tests = true  # Set to false to run only specific tests
var log_debug_info = true  # Set to true for more verbose output

# Test-specific flags
var test_view_mode_switching = true
var test_camera_view_mode_behavior = true
var test_coordinate_transformations = true
var test_view_mode_detection = true
var test_debug_manager_integration = true

# ===== TEST VARIABLES =====
var district: Node2D
var camera: Camera2D
var debug_manager: Node
var test_results = {}
var current_test = ""
var tests_passed = 0
var tests_failed = 0
var failed_tests = []

# ===== LIFECYCLE METHODS =====

func _ready():
    # Set up the test environment
    debug_log("Setting up View Mode Transition test...")
    
    # Create test scene
    create_test_scene()
    
    # Run the tests
    yield(get_tree().create_timer(0.5), "timeout")  # Short delay to ensure setup is complete
    yield(run_tests(), "completed")
    
    # Report results
    report_results()
    
    # Clean up
    cleanup_test_scene()

func _process(delta):
    # Update the status display if needed
    update_test_display()

# ===== TEST SETUP METHODS =====

func create_test_scene():
    # Create mock district
    district = create_mock_district()
    add_child(district)
    
    # Create camera
    camera = create_mock_camera()
    district.add_child(camera)
    
    # Create debug manager
    debug_manager = create_mock_debug_manager()
    add_child(debug_manager)
    
    debug_log("Test scene created with district, camera, and debug manager")

func create_mock_district():
    # Create district node
    var new_district = Node2D.new()
    new_district.name = "MockDistrict"
    
    # Add district script
    new_district.set_script(GDScript.new())
    new_district.get_script().source_code = """
    extends Node2D
    
    var background_scale_factor = 2.0
    var district_name = "Test District"
    var background_size = Vector2(1920, 1080)
    
    func get_camera():
        for child in get_children():
            if child is Camera2D:
                return child
        return null
        
    func screen_to_world_coords(screen_pos):
        var camera = get_camera()
        if camera and camera.has_method("screen_to_world"):
            return camera.screen_to_world(screen_pos)
        return screen_pos
        
    func world_to_screen_coords(world_pos):
        var camera = get_camera()
        if camera and camera.has_method("world_to_screen"):
            return camera.world_to_screen(world_pos)
        return world_pos
    """
    new_district.get_script().reload()
    
    return new_district

func create_mock_camera():
    # Create camera node
    var camera_script = load("res://src/core/camera/scrolling_camera.gd")
    var new_camera = Camera2D.new()
    new_camera.name = "ScrollingCamera"
    new_camera.set_script(camera_script)
    
    # Configure camera
    new_camera.current = true
    new_camera.global_position = Vector2(500, 300)
    new_camera.smoothing_enabled = true
    
    return new_camera

func create_mock_debug_manager():
    # Create debug manager node
    var new_debug_manager = Node.new()
    new_debug_manager.name = "MockDebugManager"
    
    # Add debug manager script
    new_debug_manager.set_script(GDScript.new())
    new_debug_manager.get_script().source_code = """
    extends Node
    
    var full_view_mode = false
    var camera = null
    
    func set_full_view_mode(enabled):
        full_view_mode = enabled
    
    func set_camera(cam):
        camera = cam
    """
    new_debug_manager.get_script().reload()
    
    # Set camera reference in debug manager
    new_debug_manager.set_camera(camera)
    
    return new_debug_manager

func cleanup_test_scene():
    # Remove test scene elements
    if district:
        district.queue_free()
    if debug_manager:
        debug_manager.queue_free()
    
    district = null
    camera = null
    debug_manager = null

# ===== TEST RUNNER =====

func run_tests():
    debug_log("Starting View Mode Transition tests...")
    
    # Reset test counters
    tests_passed = 0
    tests_failed = 0
    failed_tests = []
    test_results = {}
    
    # Run all test suites in sequence
    if run_all_tests or test_view_mode_switching:
        yield(test_view_mode_switching_suite(), "completed")
    
    if run_all_tests or test_camera_view_mode_behavior:
        yield(test_camera_view_mode_behavior_suite(), "completed")
    
    if run_all_tests or test_coordinate_transformations:
        yield(test_coordinate_transformations_suite(), "completed")
    
    if run_all_tests or test_view_mode_detection:
        yield(test_view_mode_detection_suite(), "completed")
    
    if run_all_tests or test_debug_manager_integration:
        yield(test_debug_manager_integration_suite(), "completed")
    
    debug_log("All tests completed.")

# ===== TEST SUITES =====

func test_view_mode_switching_suite():
    start_test_suite("View Mode Switching")
    
    # Test 1: Toggle world view mode
    yield(test_toggle_world_view_mode(), "completed")
    
    # Test 2: Transition from game view to world view
    yield(test_game_to_world_view_transition(), "completed")
    
    # Test 3: Transition from world view to game view
    yield(test_world_to_game_view_transition(), "completed")
    
    end_test_suite()
    yield(get_tree(), "idle_frame")

func test_camera_view_mode_behavior_suite():
    start_test_suite("Camera View Mode Behavior")
    
    # Test 1: Camera zoom in world view
    yield(test_camera_zoom_in_world_view(), "completed")
    
    # Test 2: Camera bounds in world view
    yield(test_camera_bounds_in_world_view(), "completed")
    
    # Test 3: Player following in world view
    yield(test_player_following_in_world_view(), "completed")
    
    end_test_suite()
    yield(get_tree(), "idle_frame")

func test_coordinate_transformations_suite():
    start_test_suite("Coordinate Transformations")
    
    # Test 1: Screen to world in different view modes
    yield(test_screen_to_world_in_view_modes(), "completed")
    
    # Test 2: World to screen in different view modes
    yield(test_world_to_screen_in_view_modes(), "completed")
    
    # Test 3: Coordinate transformations during transition
    yield(test_coordinate_transformations_during_transition(), "completed")
    
    end_test_suite()
    yield(get_tree(), "idle_frame")

func test_view_mode_detection_suite():
    start_test_suite("View Mode Detection")
    
    # Test 1: Detect view mode from debug manager
    yield(test_detect_view_mode_from_debug(), "completed")
    
    # Test 2: View mode detection with CoordinateSystem
    yield(test_coordinate_system_view_mode_detection(), "completed")
    
    # Test 3: View mode detection with CoordinateManager
    yield(test_coordinate_manager_view_mode_detection(), "completed")
    
    end_test_suite()
    yield(get_tree(), "idle_frame")

func test_debug_manager_integration_suite():
    start_test_suite("Debug Manager Integration")
    
    # Test 1: Debug manager controls view mode
    yield(test_debug_manager_controls_view_mode(), "completed")
    
    # Test 2: Debug indicators in different view modes
    yield(test_debug_indicators_in_view_modes(), "completed")
    
    # Test 3: Debug coordinate picker in different view modes
    yield(test_debug_coordinate_picker_in_view_modes(), "completed")
    
    end_test_suite()
    yield(get_tree(), "idle_frame")

# ===== INDIVIDUAL TESTS =====

# VIEW MODE SWITCHING TESTS

func test_toggle_world_view_mode():
    start_test("Toggle World View Mode")
    
    # Save original state
    var original_mode = camera.world_view_mode
    
    # Toggle world view mode
    camera.world_view_mode = !camera.world_view_mode
    
    # Check if mode changed
    var mode_changed = camera.world_view_mode != original_mode
    
    # Restore original state
    camera.world_view_mode = original_mode
    
    end_test(mode_changed, "Camera world_view_mode should be toggleable")
    yield(get_tree(), "idle_frame")

func test_game_to_world_view_transition():
    start_test("Game to World View Transition")
    
    # Ensure starting in game view
    camera.world_view_mode = false
    
    # Save original position and zoom
    var original_position = camera.global_position
    var original_zoom = camera.zoom
    
    # Transition to world view
    camera.world_view_mode = true
    
    # Let scene update for a frame
    yield(get_tree(), "idle_frame")
    
    # Check if view changed
    var zoom_changed = camera.zoom != original_zoom || camera.global_position != original_position
    
    # Restore original state
    camera.world_view_mode = false
    camera.global_position = original_position
    camera.zoom = original_zoom
    
    end_test(zoom_changed, "Transitioning to world view should change camera zoom or position")
    yield(get_tree(), "idle_frame")

func test_world_to_game_view_transition():
    start_test("World to Game View Transition")
    
    # Ensure starting in world view
    camera.world_view_mode = true
    
    # Save original position and zoom
    var original_position = camera.global_position
    var original_zoom = camera.zoom
    
    # Transition to game view
    camera.world_view_mode = false
    
    # Let scene update for a frame
    yield(get_tree(), "idle_frame")
    
    # Check if view changed
    var view_changed = camera.zoom != original_zoom || camera.global_position != original_position
    
    # Restore original state
    camera.world_view_mode = false
    camera.global_position = Vector2(500, 300)
    camera.zoom = Vector2(1, 1)
    
    end_test(view_changed, "Transitioning to game view should change camera zoom or position")
    yield(get_tree(), "idle_frame")

# CAMERA VIEW MODE BEHAVIOR TESTS

func test_camera_zoom_in_world_view():
    start_test("Camera Zoom in World View")
    
    # Save original state
    var original_mode = camera.world_view_mode
    var original_zoom = camera.zoom
    
    # Switch to world view
    camera.world_view_mode = true
    
    # Let scene update for a frame
    yield(get_tree(), "idle_frame")
    
    # Try zooming in world view
    camera.zoom = Vector2(2, 2)
    
    # Switch back to game view
    camera.world_view_mode = false
    
    # Check if zoom is restored to original after switching back
    var zoom_restored = camera.zoom != Vector2(2, 2)
    
    # Restore original state
    camera.world_view_mode = original_mode
    camera.zoom = original_zoom
    
    end_test(zoom_restored, "Camera zoom should restore after switching from world view to game view")
    yield(get_tree(), "idle_frame")

func test_camera_bounds_in_world_view():
    start_test("Camera Bounds in World View")
    
    # Save original state
    var original_mode = camera.world_view_mode
    var original_bounds_enabled = camera.bounds_enabled
    
    # Enable bounds
    camera.bounds_enabled = true
    
    # Switch to world view
    camera.world_view_mode = true
    
    # Let scene update for a frame
    yield(get_tree(), "idle_frame")
    
    # Test if bounds are disabled in world view or still active
    var bounds_affected = camera.bounds_enabled != original_bounds_enabled
    
    # Restore original state
    camera.world_view_mode = original_mode
    camera.bounds_enabled = original_bounds_enabled
    
    # Test passes as long as behavior is consistent
    end_test(true, "Camera bounds behavior should be consistent in world view mode")
    yield(get_tree(), "idle_frame")

func test_player_following_in_world_view():
    start_test("Player Following in World View")
    
    # Create mock player
    var player = Node2D.new()
    player.name = "MockPlayer"
    player.add_to_group("player")
    district.add_child(player)
    
    # Save original state
    var original_mode = camera.world_view_mode
    var original_follow_player = camera.follow_player
    
    # Enable player following
    camera.follow_player = true
    camera.target_player = player
    
    # Switch to world view
    camera.world_view_mode = true
    
    # Let scene update for a frame
    yield(get_tree(), "idle_frame")
    
    # Move player
    player.global_position = Vector2(700, 400)
    
    # Let scene update for a few frames
    yield(get_tree().create_timer(0.2), "timeout")
    
    # Check if camera follows player in world view
    var camera_moved = camera.global_position != Vector2(500, 300)
    
    # Restore original state
    camera.world_view_mode = original_mode
    camera.follow_player = original_follow_player
    
    # Clean up
    player.queue_free()
    
    end_test(!camera_moved, "Camera should not follow player in world view mode")
    yield(get_tree(), "idle_frame")

# COORDINATE TRANSFORMATIONS TESTS

func test_screen_to_world_in_view_modes():
    start_test("Screen to World in View Modes")
    
    # Get test point (screen center)
    var screen_center = get_viewport().get_size() / 2
    
    # Test in game view
    camera.world_view_mode = false
    var game_view_result = camera.screen_to_world(screen_center)
    
    # Test in world view
    camera.world_view_mode = true
    var world_view_result = camera.screen_to_world(screen_center)
    
    # Compare results - they should be different due to scaling
    var results_differ = game_view_result != world_view_result
    
    # Restore camera to game view
    camera.world_view_mode = false
    
    end_test(results_differ, "Screen-to-world coordinates should differ between view modes")
    yield(get_tree(), "idle_frame")

func test_world_to_screen_in_view_modes():
    start_test("World to Screen in View Modes")
    
    # Get test point (camera position)
    var world_point = camera.global_position
    
    # Test in game view
    camera.world_view_mode = false
    var game_view_result = camera.world_to_screen(world_point)
    
    # Test in world view
    camera.world_view_mode = true
    var world_view_result = camera.world_to_screen(world_point)
    
    # Compare results - they might be the same or different depending on implementation
    
    # Restore camera to game view
    camera.world_view_mode = false
    
    # Since different implementations can handle this differently, we just check
    # that the function doesn't crash and returns valid results
    var valid_results = !is_nan(game_view_result.x) && !is_nan(world_view_result.x)
    
    end_test(valid_results, "World-to-screen coordinates should return valid results in both view modes")
    yield(get_tree(), "idle_frame")

func test_coordinate_transformations_during_transition():
    start_test("Coordinate Transformations During Transition")
    
    # Get test point
    var test_point = Vector2(100, 100)
    
    # Create CoordinateManager
    var coordinate_manager = load("res://src/core/coordinate_manager.gd").new()
    coordinate_manager._current_district = district
    add_child(coordinate_manager)
    
    # Test in game view
    camera.world_view_mode = false
    coordinate_manager._current_view_mode = coordinate_manager.ViewMode.GAME_VIEW
    var game_view_result = coordinate_manager.screen_to_world(test_point)
    
    # Switch to world view
    camera.world_view_mode = true
    coordinate_manager._current_view_mode = coordinate_manager.ViewMode.WORLD_VIEW
    
    # Test in world view
    var world_view_result = coordinate_manager.screen_to_world(test_point)
    
    # Get scale factor from district
    var scale_factor = district.background_scale_factor
    
    # Check if results scale correctly
    var expected_scale_ratio = scale_factor
    var actual_ratio = world_view_result.length() / game_view_result.length()
    var scale_ratio_correct = abs(actual_ratio - expected_scale_ratio) < 0.5
    
    # Clean up
    coordinate_manager.queue_free()
    
    # Restore camera to game view
    camera.world_view_mode = false
    
    end_test(scale_ratio_correct, "Coordinate transformations should respect scale factor during view mode transitions")
    yield(get_tree(), "idle_frame")

# VIEW MODE DETECTION TESTS

func test_detect_view_mode_from_debug():
    start_test("Detect View Mode from Debug")
    
    # Set debug manager to world view
    debug_manager.full_view_mode = true
    
    # Detect view mode
    var detected_mode = CoordinateSystem.get_current_view_mode(debug_manager)
    
    # Check if detected correctly
    var detected_correctly = detected_mode == CoordinateSystem.ViewMode.WORLD_VIEW
    
    # Set debug manager back to game view
    debug_manager.full_view_mode = false
    
    end_test(detected_correctly, "CoordinateSystem should correctly detect world view mode from debug manager")
    yield(get_tree(), "idle_frame")

func test_coordinate_system_view_mode_detection():
    start_test("CoordinateSystem View Mode Detection")
    
    # Test with full_view_mode = true
    debug_manager.full_view_mode = true
    var world_view_detected = CoordinateSystem.get_current_view_mode(debug_manager) == CoordinateSystem.ViewMode.WORLD_VIEW
    
    # Test with full_view_mode = false
    debug_manager.full_view_mode = false
    var game_view_detected = CoordinateSystem.get_current_view_mode(debug_manager) == CoordinateSystem.ViewMode.GAME_VIEW
    
    # Test with null debug manager
    var fallback_to_game_view = CoordinateSystem.get_current_view_mode(null) == CoordinateSystem.ViewMode.GAME_VIEW
    
    end_test(world_view_detected && game_view_detected && fallback_to_game_view, 
             "CoordinateSystem should correctly detect view mode in all cases")
    yield(get_tree(), "idle_frame")

func test_coordinate_manager_view_mode_detection():
    start_test("CoordinateManager View Mode Detection")
    
    # Create CoordinateManager
    var coordinate_manager = load("res://src/core/coordinate_manager.gd").new()
    add_child(coordinate_manager)
    
    # Set debug manager to world view
    debug_manager.full_view_mode = true
    
    # Detect view mode
    var detected_mode = coordinate_manager.detect_view_mode_from_debug(debug_manager)
    
    # Check if detected correctly
    var detected_correctly = detected_mode == coordinate_manager.ViewMode.WORLD_VIEW
    
    # Set debug manager back to game view
    debug_manager.full_view_mode = false
    
    # Clean up
    coordinate_manager.queue_free()
    
    end_test(detected_correctly, "CoordinateManager should correctly detect world view mode from debug manager")
    yield(get_tree(), "idle_frame")

# DEBUG MANAGER INTEGRATION TESTS

func test_debug_manager_controls_view_mode():
    start_test("Debug Manager Controls View Mode")
    
    # Save original state
    var original_camera_mode = camera.world_view_mode
    
    # Set debug manager's full view mode
    debug_manager.full_view_mode = true
    
    # Test if camera's view mode can be controlled by debug manager
    # Update the camera manually since we don't have the real connections
    camera.world_view_mode = debug_manager.full_view_mode
    
    # Check if camera mode matches debug manager
    var camera_mode_matches = camera.world_view_mode == debug_manager.full_view_mode
    
    # Set debug manager back to original state
    debug_manager.full_view_mode = false
    
    # Restore camera state
    camera.world_view_mode = original_camera_mode
    
    end_test(camera_mode_matches, "Camera view mode should be controllable by debug manager")
    yield(get_tree(), "idle_frame")

func test_debug_indicators_in_view_modes():
    start_test("Debug Indicators in View Modes")
    
    # Enable debug drawing
    camera.debug_draw = true
    
    # Test in game view
    camera.world_view_mode = false
    
    # Let scene update for a frame
    yield(get_tree(), "idle_frame")
    
    # Test in world view
    camera.world_view_mode = true
    
    # Let scene update for a frame
    yield(get_tree(), "idle_frame")
    
    # Disable debug drawing
    camera.debug_draw = false
    
    # Restore camera to game view
    camera.world_view_mode = false
    
    # This test is mostly checking that it doesn't crash
    end_test(true, "Debug indicators should handle view mode transitions without errors")
    yield(get_tree(), "idle_frame")

func test_debug_coordinate_picker_in_view_modes():
    start_test("Debug Coordinate Picker in View Modes")
    
    # Create a mock coordinate picker that records the view mode
    var picker_script = GDScript.new()
    picker_script.source_code = """
    extends Node
    
    var view_mode_recorded = null
    
    func record_coordinate(point, view_mode):
        view_mode_recorded = view_mode
        return true
    """
    picker_script.reload()
    
    var mock_picker = Node.new()
    mock_picker.name = "MockCoordinatePicker"
    mock_picker.set_script(picker_script)
    add_child(mock_picker)
    
    # Test in game view
    camera.world_view_mode = false
    mock_picker.record_coordinate(Vector2(100, 100), CoordinateSystem.ViewMode.GAME_VIEW)
    var game_view_recorded = mock_picker.view_mode_recorded == CoordinateSystem.ViewMode.GAME_VIEW
    
    # Test in world view
    camera.world_view_mode = true
    mock_picker.record_coordinate(Vector2(100, 100), CoordinateSystem.ViewMode.WORLD_VIEW)
    var world_view_recorded = mock_picker.view_mode_recorded == CoordinateSystem.ViewMode.WORLD_VIEW
    
    # Clean up
    mock_picker.queue_free()
    
    # Restore camera to game view
    camera.world_view_mode = false
    
    end_test(game_view_recorded && world_view_recorded, "Debug coordinate picker should record the correct view mode")
    yield(get_tree(), "idle_frame")

# ===== TEST UTILITIES =====

func update_test_display():
    # Update any UI elements showing test status
    var label = get_node_or_null("TestInfo")
    if label:
        var status = "Tests: %d/%d passed" % [tests_passed, tests_passed + tests_failed]
        if current_test:
            status += "\nCurrent: " + current_test
        label.text = status

func start_test_suite(suite_name):
    debug_log("===== TEST SUITE: " + suite_name + " =====", true)
    test_results[suite_name] = {
        "passed": 0,
        "failed": 0,
        "tests": {}
    }

func end_test_suite():
    var suite_name = current_test.split(":")[0]
    var passed = test_results[suite_name].passed
    var failed = test_results[suite_name].failed
    var total = passed + failed
    debug_log("Suite completed: " + str(passed) + "/" + str(total) + " tests passed", true)

func start_test(test_name):
    var suite_name = test_name.split(" ")[0]
    current_test = suite_name + ": " + test_name
    debug_log("Running test: " + test_name)

func end_test(passed, message = ""):
    var parts = current_test.split(": ")
    var suite_name = parts[0]
    var test_name = parts[1]
    
    if passed:
        debug_log("âœ“ PASS: " + test_name + (": " + message if message else ""))
        test_results[suite_name].passed += 1
        tests_passed += 1
    else:
        debug_log("âœ— FAIL: " + test_name + (": " + message if message else ""), true)
        test_results[suite_name].failed += 1
        tests_failed += 1
        failed_tests.append(current_test)
    
    test_results[suite_name].tests[test_name] = {
        "passed": passed,
        "message": message
    }

func report_results():
    debug_log("\n===== TEST RESULTS =====", true)
    debug_log("Total Tests: " + str(tests_passed + tests_failed), true)
    debug_log("Passed: " + str(tests_passed), true)
    debug_log("Failed: " + str(tests_failed), true)
    
    if tests_failed > 0:
        debug_log("\nFailed Tests:", true)
        for test in failed_tests:
            var parts = test.split(": ")
            var suite_name = parts[0]
            var test_name = parts[1]
            var message = test_results[suite_name].tests[test_name].message
            debug_log("- " + test + (": " + message if message else ""), true)
    
    if tests_failed == 0:
        debug_log("\nAll tests passed! ðŸŽ‰", true)

func debug_debug_log(message, force_print = false):
    if log_debug_info || force_print:
        print(message)