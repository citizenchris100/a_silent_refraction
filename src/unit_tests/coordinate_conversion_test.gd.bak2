extends Node2D
# Coordinate Conversion Test: A comprehensive test suite for the enhanced coordinate conversion system

# ===== TEST CONFIGURATION =====
var run_all_tests = true  # Set to false to run only specific tests
var log_debug_info = true  # Set to true for more verbose output

# Test-specific flags
var test_coordinate_transformations = true
var test_coordinate_validation = true
var test_camera_boundaries = true
var test_edge_case_handling = true
var test_is_point_in_view = true
var test_coordinate_manager_integration = true
var test_zoom_behavior = true

# ===== TEST VARIABLES =====
var camera: Camera2D
var test_results = {}
var current_test = ""
var tests_passed = 0
var tests_failed = 0
var failed_tests = []

# Constants for testing coordinates
const TEST_POINTS = [
	Vector2(0, 0),        # Origin point
	Vector2(100, 100),    # Regular point
	Vector2(-100, -100),  # Negative coordinates
	Vector2(9999, 9999),  # Extremely large value
	Vector2(0.5, 0.5)     # Fractional value
]

# ===== LIFECYCLE METHODS =====

func _ready():
	# Set up the test environment
	debug_log("Setting up coordinate conversion test...")
	
	# Find or create the camera
	camera = find_camera()
	if not camera:
		debug_log("ERROR: Could not find or create a ScrollingCamera instance", true)
		return
	
	# Configure camera for testing
	configure_camera()
	
	# Run the tests
	yield(get_tree().create_timer(0.5), "timeout")  # Short delay to ensure setup is complete
	yield(run_tests(), "completed")
	
	# Report results
	report_results()

func _process(delta):
	# Update the status display if needed
	update_test_display()

# ===== TEST SETUP METHODS =====

func find_camera():
	# Try to find the ScrollingCamera in the scene
	var cameras = get_tree().get_nodes_in_group("camera")
	for cam in cameras:
		if cam is Camera2D:
			debug_log("Found existing camera: " + cam.name)
			return cam
	
	# If no camera found, look for our specific class
	for node in get_tree().get_nodes_in_group("camera"):
		if "CameraState" in node:
			debug_log("Found ScrollingCamera: " + node.name)
			return node
	
	# Create a new camera if no existing camera found
	debug_log("Creating new ScrollingCamera instance")
	var scene = load("res://src/core/camera/scrolling_camera.gd")
	if scene:
		var new_camera = scene.new()
		add_child(new_camera)
		return new_camera
	
	return null

func configure_camera():
	debug_log("Configuring camera for testing...")
	
	# Enable debug visualization for testing
	camera.debug_draw = true
	
	# Ensure the camera has specific testing properties
	camera.bounds_enabled = true
	camera.camera_bounds = Rect2(0, 0, 1000, 1000)
	
	# Set initial position
	camera.global_position = Vector2(500, 500)
	
	# Set zoom for testing
	camera.zoom = Vector2(1, 1)
	
	debug_log("Camera configured with position: " + str(camera.global_position) + ", zoom: " + str(camera.zoom))

# ===== TEST RUNNER =====

func run_tests():
	debug_log("Starting coordinate conversion tests...")
	
	# Reset test counters
	tests_passed = 0
	tests_failed = 0
	failed_tests = []
	test_results = {}
	
	# Run all test suites in sequence
	if run_all_tests or test_coordinate_transformations:
		yield(test_coordinate_transformations_suite(), "completed")
	
	if run_all_tests or test_coordinate_validation:
		yield(test_coordinate_validation_suite(), "completed")
	
	if run_all_tests or test_camera_boundaries:
		yield(test_camera_boundaries_suite(), "completed")
	
	if run_all_tests or test_edge_case_handling:
		yield(test_edge_case_handling_suite(), "completed")
	
	if run_all_tests or test_is_point_in_view:
		yield(test_is_point_in_view_suite(), "completed")
	
	if run_all_tests or test_coordinate_manager_integration:
		yield(test_coordinate_manager_integration_suite(), "completed")
	
	if run_all_tests or test_zoom_behavior:
		yield(test_zoom_behavior_suite(), "completed")
	
	debug_log("All tests completed.")

# ===== TEST SUITES =====

func test_coordinate_transformations_suite():
	start_test_suite("Coordinate Transformations")
	
	# Test 1: World to screen conversion
	yield(test_world_to_screen_conversion(), "completed")
	
	# Test 2: Screen to world conversion
	yield(test_screen_to_world_conversion(), "completed")
	
	# Test 3: Round-trip conversion accuracy
	yield(test_coordinate_round_trip(), "completed")
	
	end_test_suite()
	yield(get_tree(), "idle_frame")

func test_coordinate_validation_suite():
	start_test_suite("Coordinate Validation")
	
	# Test 1: Validate coordinates method handles NaN
	yield(test_validate_coordinates_nan(), "completed")
	
	# Test 2: Validate coordinates method handles Infinity
	yield(test_validate_coordinates_infinity(), "completed")
	
	# Test 3: Validate coordinates method handles extreme values
	yield(test_validate_coordinates_extreme(), "completed")
	
	end_test_suite()
	yield(get_tree(), "idle_frame")

func test_camera_boundaries_suite():
	start_test_suite("Camera Boundaries")
	
	# Test 1: Ensure valid target method
	yield(test_ensure_valid_target(), "completed")
	
	# Test 2: Boundary limiting
	yield(test_boundary_limiting(), "completed")
	
	end_test_suite()
	yield(get_tree(), "idle_frame")

func test_edge_case_handling_suite():
	start_test_suite("Edge Case Handling")
	
	# Test 1: Edge case handling at screen boundaries
	yield(test_edge_case_screen_boundaries(), "completed")
	
	# Test 2: Edge case handling at world boundaries
	yield(test_edge_case_world_boundaries(), "completed")
	
	end_test_suite()
	yield(get_tree(), "idle_frame")

func test_is_point_in_view_suite():
	start_test_suite("Is Point In View")
	
	# Test 1: Points within view
	yield(test_points_within_view(), "completed")
	
	# Test 2: Points outside view
	yield(test_points_outside_view(), "completed")
	
	# Test 3: Points at view boundaries
	yield(test_points_at_view_boundaries(), "completed")
	
	end_test_suite()
	yield(get_tree(), "idle_frame")

func test_coordinate_manager_integration_suite():
	start_test_suite("Coordinate Manager Integration")
	
	# Test 1: Camera registration with coordinate manager
	yield(test_registration_with_coordinate_manager(), "completed")
	
	end_test_suite()
	yield(get_tree(), "idle_frame")

func test_zoom_behavior_suite():
	start_test_suite("Zoom Behavior")
	
	# Test 1: Coordinate conversion at different zoom levels
	yield(test_conversion_at_zoom_levels(), "completed")
	
	end_test_suite()
	yield(get_tree(), "idle_frame")

# ===== INDIVIDUAL TESTS =====

# COORDINATE TRANSFORMATIONS TESTS

func test_world_to_screen_conversion():
	start_test("World to Screen Conversion")
	
	# Save camera settings
	var original_position = camera.global_position
	var original_zoom = camera.zoom
	
	# Set camera to a known position and zoom
	camera.global_position = Vector2(500, 500)
	camera.zoom = Vector2(1, 1)
	
	# Get viewport size
	var viewport_size = get_viewport().get_size()
	var viewport_center = viewport_size / 2
	
	# Test world-to-screen conversion
	var world_point = Vector2(600, 600) # 100 units right and down from camera position
	var expected_screen_point = viewport_center + Vector2(100, 100)
	var screen_point = camera.world_to_screen(world_point)
	
	# Restore camera settings
	camera.global_position = original_position
	camera.zoom = original_zoom
	
	# Test passes if screen point is close to expected
	var close_enough = screen_point.distance_to(expected_screen_point) < 5
	end_test(close_enough, "World-to-screen conversion should match expected result")
	yield(get_tree(), "idle_frame")

func test_screen_to_world_conversion():
	start_test("Screen to World Conversion")
	
	# Save camera settings
	var original_position = camera.global_position
	var original_zoom = camera.zoom
	
	# Set camera to a known position and zoom
	camera.global_position = Vector2(500, 500)
	camera.zoom = Vector2(1, 1)
	
	# Get viewport size
	var viewport_size = get_viewport().get_size()
	var viewport_center = viewport_size / 2
	
	# Test screen-to-world conversion
	var screen_point = viewport_center + Vector2(100, 100) # 100 pixels right and down from center
	var expected_world_point = Vector2(600, 600)
	var world_point = camera.screen_to_world(screen_point)
	
	# Restore camera settings
	camera.global_position = original_position
	camera.zoom = original_zoom
	
	# Test passes if world point is close to expected
	var close_enough = world_point.distance_to(expected_world_point) < 5
	end_test(close_enough, "Screen-to-world conversion should match expected result")
	yield(get_tree(), "idle_frame")

func test_coordinate_round_trip():
	start_test("Coordinate Round Trip")
	
	# Save camera settings
	var original_position = camera.global_position
	var original_zoom = camera.zoom
	
	# Set camera to a known position and zoom
	camera.global_position = Vector2(500, 500)
	camera.zoom = Vector2(1, 1)
	
	# Test round-trip conversion for all test points
	var all_points_valid = true
	for point in TEST_POINTS:
		# Convert world point to screen
		var screen_point = camera.world_to_screen(point)
		# Convert screen point back to world
		var round_trip_point = camera.screen_to_world(screen_point)
		# Check if round-trip conversion is accurate
		if round_trip_point.distance_to(point) > 1:
			all_points_valid = false
			debug_log("Round-trip test failed for point " + str(point) + ": " + 
				"Result: " + str(round_trip_point), true)
	
	# Restore camera settings
	camera.global_position = original_position
	camera.zoom = original_zoom
	
	# Test passes if all round-trip conversions are accurate
	end_test(all_points_valid, "Round-trip conversions should return to original coordinates")
	yield(get_tree(), "idle_frame")

# COORDINATE VALIDATION TESTS

func test_validate_coordinates_nan():
	start_test("Validate Coordinates NaN")
	
	# Create a point with NaN value
	var nan_point = Vector2(NAN, 100)
	
	# Validate the point
	var validated_point = camera.validate_coordinates(nan_point)
	
	# Check if validation handled NaN correctly
	var handled_correctly = !is_nan(validated_point.x) && !is_nan(validated_point.y)
	
	# Test passes if NaN was handled correctly
	end_test(handled_correctly, "validate_coordinates should handle NaN values")
	yield(get_tree(), "idle_frame")

func test_validate_coordinates_infinity():
	start_test("Validate Coordinates Infinity")
	
	# Create a point with infinity value
	var inf_point = Vector2(INF, 100)
	
	# Validate the point
	var validated_point = camera.validate_coordinates(inf_point)
	
	# Check if validation handled infinity correctly
	var handled_correctly = !is_inf(validated_point.x) && !is_inf(validated_point.y)
	
	# Test passes if infinity was handled correctly
	end_test(handled_correctly, "validate_coordinates should handle infinity values")
	yield(get_tree(), "idle_frame")

func test_validate_coordinates_extreme():
	start_test("Validate Coordinates Extreme")
	
	# Create a point with extreme value
	var extreme_point = Vector2(1000000, 1000000)
	
	# Validate the point
	var validated_point = camera.validate_coordinates(extreme_point)
	
	# Check if validation handled extreme value
	var handled_correctly = abs(validated_point.x) < 100000 || abs(validated_point.y) < 100000
	
	# Test passes if extreme value was handled or left as-is (implementation dependent)
	end_test(true, "validate_coordinates should handle or allow extreme values")
	yield(get_tree(), "idle_frame")

# CAMERA BOUNDARIES TESTS

func test_ensure_valid_target():
	start_test("Ensure Valid Target")
	
	# Save camera settings
	var original_position = camera.global_position
	var original_bounds = camera.camera_bounds
	
	# Set camera bounds
	camera.bounds_enabled = true
	camera.camera_bounds = Rect2(0, 0, 1000, 1000)
	
	# Test position within bounds
	var within_bounds_pos = Vector2(500, 500)
	var validated_within = camera.ensure_valid_target(within_bounds_pos)
	var within_bounds_valid = validated_within.distance_to(within_bounds_pos) < 5
	
	# Test position outside bounds
	var outside_bounds_pos = Vector2(2000, 2000)
	var validated_outside = camera.ensure_valid_target(outside_bounds_pos)
	var outside_bounds_valid = validated_outside.x <= (camera.camera_bounds.position.x + camera.camera_bounds.size.x) &&
							   validated_outside.y <= (camera.camera_bounds.position.y + camera.camera_bounds.size.y)
	
	# Restore camera settings
	camera.global_position = original_position
	camera.camera_bounds = original_bounds
	
	# Test passes if both cases are handled correctly
	var both_valid = within_bounds_valid && outside_bounds_valid
	end_test(both_valid, "ensure_valid_target should respect camera bounds")
	yield(get_tree(), "idle_frame")

func test_boundary_limiting():
	start_test("Boundary Limiting")
	
	# Save camera settings
	var original_position = camera.global_position
	var original_bounds = camera.camera_bounds
	
	# Set camera bounds
	camera.bounds_enabled = true
	camera.camera_bounds = Rect2(0, 0, 1000, 1000)
	
	# Get viewport size and calculate how close camera can get to edge
	var viewport_size = get_viewport().get_size()
	var camera_half_size = viewport_size / 2 / camera.zoom
	
	# Test positions at each boundary
	var min_x = camera.camera_bounds.position.x + camera_half_size.x
	var max_x = camera.camera_bounds.position.x + camera.camera_bounds.size.x - camera_half_size.x
	var min_y = camera.camera_bounds.position.y + camera_half_size.y
	var max_y = camera.camera_bounds.position.y + camera.camera_bounds.size.y - camera_half_size.y
	
	# Test left boundary
	var left_pos = Vector2(min_x - 100, 500) # Try to go 100 units beyond left boundary
	var validated_left = camera.ensure_valid_target(left_pos)
	var left_valid = validated_left.x >= min_x
	
	# Test right boundary
	var right_pos = Vector2(max_x + 100, 500) # Try to go 100 units beyond right boundary
	var validated_right = camera.ensure_valid_target(right_pos)
	var right_valid = validated_right.x <= max_x
	
	# Test top boundary
	var top_pos = Vector2(500, min_y - 100) # Try to go 100 units beyond top boundary
	var validated_top = camera.ensure_valid_target(top_pos)
	var top_valid = validated_top.y >= min_y
	
	# Test bottom boundary
	var bottom_pos = Vector2(500, max_y + 100) # Try to go 100 units beyond bottom boundary
	var validated_bottom = camera.ensure_valid_target(bottom_pos)
	var bottom_valid = validated_bottom.y <= max_y
	
	# Restore camera settings
	camera.global_position = original_position
	camera.camera_bounds = original_bounds
	
	# Test passes if all boundaries are enforced
	var all_boundaries_valid = left_valid && right_valid && top_valid && bottom_valid
	end_test(all_boundaries_valid, "Camera should respect all boundary limits")
	yield(get_tree(), "idle_frame")

# EDGE CASE HANDLING TESTS

func test_edge_case_screen_boundaries():
	start_test("Edge Case Screen Boundaries")
	
	# Save camera settings
	var original_position = camera.global_position
	var original_zoom = camera.zoom
	
	# Set camera to a known position and zoom
	camera.global_position = Vector2(500, 500)
	camera.zoom = Vector2(1, 1)
	
	# Get viewport size
	var viewport_size = get_viewport().get_size()
	
	# Test edge of screen (just beyond viewport)
	var edge_screen_point = Vector2(-10, -10) # Just outside viewport
	var edge_world_point = camera.screen_to_world(edge_screen_point)
	
	# Should be handled without errors
	var handled_correctly = true # Just check that it doesn't crash
	
	# Restore camera settings
	camera.global_position = original_position
	camera.zoom = original_zoom
	
	# Test passes if edge case was handled without errors
	end_test(handled_correctly, "Camera should handle screen points at viewport edges")
	yield(get_tree(), "idle_frame")

func test_edge_case_world_boundaries():
	start_test("Edge Case World Boundaries")
	
	# Save camera settings
	var original_position = camera.global_position
	var original_bounds = camera.camera_bounds
	
	# Set camera bounds to a small area
	camera.bounds_enabled = true
	camera.camera_bounds = Rect2(0, 0, 100, 100)
	
	# Try to position camera exactly at boundary
	var boundary_pos = Vector2(0, 0) # Left-top corner of bounds
	var validated_pos = camera.ensure_valid_target(boundary_pos)
	
	# Should not be exactly at boundary due to half-size calculation
	var handled_correctly = validated_pos != boundary_pos
	
	# Restore camera settings
	camera.global_position = original_position
	camera.camera_bounds = original_bounds
	
	# Test passes if edge case at world boundary was handled
	end_test(handled_correctly, "Camera should handle positions at world boundaries")
	yield(get_tree(), "idle_frame")

# IS POINT IN VIEW TESTS

func test_points_within_view():
	start_test("Points Within View")
	
	# Save camera settings
	var original_position = camera.global_position
	var original_zoom = camera.zoom
	
	# Set camera to a known position and zoom
	camera.global_position = Vector2(500, 500)
	camera.zoom = Vector2(1, 1)
	
	# Get viewport size
	var viewport_size = get_viewport().get_size()
	var camera_half_size = viewport_size / 2 / camera.zoom
	
	# Test point in center of view
	var center_point = camera.global_position
	var center_in_view = camera.is_point_in_view(center_point)
	
	# Test point near edge but still in view
	var edge_point = camera.global_position + Vector2(camera_half_size.x - 10, 0)
	var edge_in_view = camera.is_point_in_view(edge_point)
	
	# Restore camera settings
	camera.global_position = original_position
	camera.zoom = original_zoom
	
	# Test passes if both points are correctly identified as in view
	var both_in_view = center_in_view && edge_in_view
	end_test(both_in_view, "is_point_in_view should correctly identify points within view")
	yield(get_tree(), "idle_frame")

func test_points_outside_view():
	start_test("Points Outside View")
	
	# Save camera settings
	var original_position = camera.global_position
	var original_zoom = camera.zoom
	
	# Set camera to a known position and zoom
	camera.global_position = Vector2(500, 500)
	camera.zoom = Vector2(1, 1)
	
	# Get viewport size
	var viewport_size = get_viewport().get_size()
	var camera_half_size = viewport_size / 2 / camera.zoom
	
	# Test point far outside view
	var far_point = camera.global_position + Vector2(camera_half_size.x + 1000, 0)
	var far_in_view = camera.is_point_in_view(far_point)
	
	# Test point just outside view
	var just_outside_point = camera.global_position + Vector2(camera_half_size.x + 10, 0)
	var just_outside_in_view = camera.is_point_in_view(just_outside_point)
	
	# Restore camera settings
	camera.global_position = original_position
	camera.zoom = original_zoom
	
	# Test passes if both points are correctly identified as outside view
	var both_outside_view = !far_in_view && !just_outside_in_view
	end_test(both_outside_view, "is_point_in_view should correctly identify points outside view")
	yield(get_tree(), "idle_frame")

func test_points_at_view_boundaries():
	start_test("Points At View Boundaries")
	
	# Save camera settings
	var original_position = camera.global_position
	var original_zoom = camera.zoom
	
	# Set camera to a known position and zoom
	camera.global_position = Vector2(500, 500)
	camera.zoom = Vector2(1, 1)
	
	# Get viewport size
	var viewport_size = get_viewport().get_size()
	var camera_half_size = viewport_size / 2 / camera.zoom
	
	# Test point exactly at view boundary
	var boundary_point = camera.global_position + Vector2(camera_half_size.x, 0)
	var boundary_in_view = camera.is_point_in_view(boundary_point)
	
	# Restore camera settings
	camera.global_position = original_position
	camera.zoom = original_zoom
	
	# Test passes if boundary point is handled consistently (may be in or out of view depending on implementation)
	var boundary_handled = true  # Accept either result for boundary case
	end_test(boundary_handled, "is_point_in_view should handle boundary points consistently")
	yield(get_tree(), "idle_frame")

# COORDINATE MANAGER INTEGRATION TESTS

func test_registration_with_coordinate_manager():
	start_test("Registration With Coordinate Manager")
	
	# This test is more of a check that the function exists and doesn't crash
	# Since the CoordinateManager is a singleton, it's hard to test without modifying the game architecture
	
	# Call the registration method
	camera.register_with_coordinate_manager()
	
	# Simply ensure it doesn't crash
	var registration_exists = "register_with_coordinate_manager" in camera
	end_test(registration_exists, "Camera should have registration method for CoordinateManager")
	yield(get_tree(), "idle_frame")

# ZOOM BEHAVIOR TESTS

func test_conversion_at_zoom_levels():
	start_test("Conversion At Zoom Levels")
	
	# Save camera settings
	var original_position = camera.global_position
	var original_zoom = camera.zoom
	
	# Set camera to a known position
	camera.global_position = Vector2(500, 500)
	
	# Test points
	var test_point = Vector2(600, 600)  # 100 units from camera
	var all_zoom_levels_valid = true
	
	# Test conversion at different zoom levels
	var zoom_levels = [Vector2(0.5, 0.5), Vector2(1, 1), Vector2(2, 2)]
	
	for zoom_level in zoom_levels:
		# Set zoom
		camera.zoom = zoom_level
		
		# Convert world point to screen
		var screen_point = camera.world_to_screen(test_point)
		
		# Convert back to world
		var round_trip_point = camera.screen_to_world(screen_point)
		
		# Check if round-trip conversion is accurate
		if round_trip_point.distance_to(test_point) > 2:
			all_zoom_levels_valid = false
			debug_log("Zoom test failed for zoom level " + str(zoom_level) + ": " + 
				"Result: " + str(round_trip_point) + " Expected: " + str(test_point), true)
	
	# Restore camera settings
	camera.global_position = original_position
	camera.zoom = original_zoom
	
	# Test passes if conversions work at all zoom levels
	end_test(all_zoom_levels_valid, "Coordinate conversions should work at different zoom levels")
	yield(get_tree(), "idle_frame")

# ===== TEST UTILITIES =====

func update_test_display():
	# Update any UI elements showing test status
	var label = get_node_or_null("TestInfo")
	if label:
		var status = "Tests: %d/%d passed" % [tests_passed, tests_passed + tests_failed]
		if current_test:
			status += "\nCurrent: " + current_test
		label.text = status

func start_test_suite(suite_name):
	debug_log("===== TEST SUITE: " + suite_name + " =====", true)
	test_results[suite_name] = {
		"passed": 0,
		"failed": 0,
		"tests": {}
	}

func end_test_suite():
	var suite_name = current_test.split(":")[0]
	var passed = test_results[suite_name].passed
	var failed = test_results[suite_name].failed
	var total = passed + failed
	debug_log("Suite completed: " + str(passed) + "/" + str(total) + " tests passed", true)

func start_test(test_name):
	var suite_name = test_name.split(" ")[0]
	current_test = suite_name + ": " + test_name
	debug_log("Running test: " + test_name)

func end_test(passed, message = ""):
	var parts = current_test.split(": ")
	var suite_name = parts[0]
	var test_name = parts[1]
	
	if passed:
		debug_log("✓ PASS: " + test_name + (": " + message if message else ""))
		test_results[suite_name].passed += 1
		tests_passed += 1
	else:
		debug_log("✗ FAIL: " + test_name + (": " + message if message else ""), true)
		test_results[suite_name].failed += 1
		tests_failed += 1
		failed_tests.append(current_test)
	
	test_results[suite_name].tests[test_name] = {
		"passed": passed,
		"message": message
	}

func report_results():
	debug_log("\n===== TEST RESULTS =====", true)
	debug_log("Total Tests: " + str(tests_passed + tests_failed), true)
	debug_log("Passed: " + str(tests_passed), true)
	debug_log("Failed: " + str(tests_failed), true)
	
	if tests_failed > 0:
		debug_log("\nFailed Tests:", true)
		for test in failed_tests:
			var parts = test.split(": ")
			var suite_name = parts[0]
			var test_name = parts[1]
			var message = test_results[suite_name].tests[test_name].message
			debug_log("- " + test + (": " + message if message else ""), true)
	
	if tests_failed == 0:
		debug_log("\nAll tests passed! 🎉", true)

func debug_debug_log(message, force_print = false):
	if log_debug_info || force_print:
		print(message)